[{"path":"https://docs.ropensci.org/cyphr/CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (https://contributor-covenant.org), version 1.0.0, available https://contributor-covenant.org/version/1/0/0/","code":""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"keys-and-the-like","dir":"Articles","previous_headings":"","what":"Keys and the like","title":"Introduction","text":"encrypt anything need key. two sorts key “types” concern “symmetric” “asymmetric”. “symmetric” keys used storing secrets multiple people need access. Everyone key (just bunch bytes) can either encrypt data decrypt . “key pair” public private key; used communication. hold private key nobody else ever sees public key can copy around show. can used couple different patterns communication (see ). support symmetric keys asymmetric key pairs openssl sodium packages (wrap around industry-standard cryptographic libraries) - vignette show create load keys different types ’re used. openssl keys advantage standard key format, many people (especially Linux macOS) keypair already (see ’re sure ). sodium keys advantage new library, starting clean slate rather carrying accumulated ideas last 20 years development. idea cyphr can abstract away differences types keys functions go create standardised interface encrypting decrypting strings, R objects, files raw vectors. , can create wrappers around functions create files simplify process adding encryption data workflow. , ’ll describe sorts keys cyphr supports sections following describe can used actually encryption.","code":""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"symmetric-encryption","dir":"Articles","previous_headings":"Keys and the like","what":"Symmetric encryption","title":"Introduction","text":"Illustration Symmetric Encryption simplest form encryption everyone key (like key house single password). raises issues (like store key without people reading ) can deal .","code":""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"openssl","dir":"Articles","previous_headings":"Keys and the like > Symmetric encryption","what":"openssl","title":"Introduction","text":"generate key openssl, can use: generates raw vector (prints nicely really stored 16 byte raw vector). encryption functions key supports openssl::aes_cbc_encrypt, openssl::aes_ctr_encrypt openssl::aes_gcm_encrypt (along corresponding decryption functions). cyphr package tries abstract away using wrapper `cyphr::key_openssl key, one can encrypt string cyphr::encrypt_string: decrypt cyphr::decrypt_string: See functions use key objects.","code":"k <- openssl::aes_keygen() k ## aes 95:eb:fa:78:84:72:e5:b6:7e:38:a5:82:77:00:ac:04 key <- cyphr::key_openssl(k) key ## <cyphr_key: openssl> secret <- cyphr::encrypt_string(\"my secret string\", key) cyphr::decrypt_string(secret, key) ## [1] \"my secret string\""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"sodium","dir":"Articles","previous_headings":"Keys and the like > Symmetric encryption","what":"sodium","title":"Introduction","text":"interface almost identical using sodium symmetric keys. generate symmetric key libsodium use sodium::keygen really just raw vector length 32, without even class attribute! encryption functions key supports sodium::data_encrypt sodium::data_decrypt. create key use cyphr knows , use: key can used high-level cyphr encryption functions described .","code":"k <- sodium::keygen() key <- cyphr::key_sodium(k) key ## <cyphr_key: sodium>"},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"asymmetric-encryption-key-pairs","dir":"Articles","previous_headings":"Keys and the like","what":"Asymmetric encryption (“key pairs”)","title":"Introduction","text":"Illustration Asymmetric Encryption asymmetric encryption everybody two keys differ everyone else’s key. One key public can shared freely anyone like communicate private must never disclosed. sodium package vignette (vignette(\"crypto101\")) gives gentle introduction works. practice, end creating pair keys . encrypt decrypt something encrypt messages recipient’s public key () can decrypt private key. One use asymmetric encryption encrypt shared secret (symmetric key) - can safely store communicate symmetric key without disclosing .","code":""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"openssl-1","dir":"Articles","previous_headings":"Keys and the like > Asymmetric encryption (“key pairs”)","what":"openssl","title":"Introduction","text":"Let’s suppose two parties “Alice” “Bob” want talk one another. demonstration purposes need generate SSH keys (password) temporary directories (comply CRAN policies). real situation different machines (Alice access Bob’s key!) keys password protected. Note directory contains public key (id_rsa.pub) private key (id_rsa). , full path key (e.g., .../id_rsa) used place directory name prefer. Alice wants send message Bob needs use private key public key pair can write message “bob”: secret now just big pile bytes Note unlike symmetric encryption , Alice decrypt message: Bob read message, uses private key Alice’s public key (transmitted previously). keypair, Bob can decrypt Alice’s message send one back : can decrypt Chances , openssl keypair .ssh/ directory. , pass NULL path private (less usefully, public) key pair part. send message Bob, ’d include path Bob’s public key. skips Alice Bob exchange secret information. secret bytes, ’s bit odd work . Alice save secret disk send Bob file for_bob_only (email insecure medium). bob read secret : alternative, can “base64 encode” bytes something can just email around: can converted back openssl::base64_decode: , less compactly also suitable email, might just convert bytes hex representation: reverse sodium::hex2bin: (somewhat less space efficient base64 encoding. final option, can just save secret saveRDS read readRDS like option. best route secret saved complicated R object (e.g., list data.frame). See cyphr vignette (vignette(\"data\", package = \"cyphr\")) suggested workflow exchanging secrets within team, wrapper functions convenient ways working encrypted data. already ssh keypair? find , run One three things happen: prompted password decrypt private key, entering object <cyphr_keypair: openssl> returned - ’re good go! prompted password, got <cyphr_keypair: openssl> object. consider whether appropriate consider generating new keypair private key encrypted. don’t anyone can read private key can decrypt message intended . get error like find default ssh public key ~/.ssh/id_rsa.pub. need create keypair. create keypair, can use cyphr::ssh_keygen() function create keypair ~/.ssh/id_rsa ~/.ssh/id_rsa.pub, cyphr look keys default. See ?ssh_keygen information. (Linux macOS might use ssh-keygen command line utility. windows, PuTTY` utility creating keys.)","code":"path_key_alice <- cyphr::ssh_keygen(password = FALSE) path_key_bob <- cyphr::ssh_keygen(password = FALSE) dir(path_key_alice) ## [1] \"id_rsa\"     \"id_rsa.pub\" dir(path_key_bob) ## [1] \"id_rsa\"     \"id_rsa.pub\" pair_a <- cyphr::keypair_openssl(path_key_bob, path_key_alice) pair_a ## <cyphr_keypair: openssl> secret <- cyphr::encrypt_string(\"secret message\", pair_a) secret ##   [1] 58 0a 00 00 00 03 00 04 03 02 00 03 05 00 00 00 00 05 55 54 46 2d 38 00 00 ##  [26] 02 13 00 00 00 04 00 00 00 18 00 00 00 10 1f f6 41 95 30 90 15 32 29 b4 91 ##  [51] 26 b6 8b 27 70 00 00 00 18 00 00 01 00 85 3d ed 8b 0a 86 29 6e a6 ce 1c 37 ##  [76] a8 0d 23 4f 43 e1 52 84 1f 0c 89 da 35 79 d1 78 c1 5b 75 69 38 71 9d 88 18 ## [101] 86 f1 97 fe f2 27 7b 25 8d 1f 7a f6 c0 62 3a 8c e5 93 86 d2 92 74 37 90 07 ## [126] 6a 88 0a 38 ab 35 00 51 87 fc 78 3a e0 84 14 23 13 7f 2d 9f ad 30 c0 cf c5 ## [151] 05 3f 56 45 cf c2 bb 7e 84 02 37 bd a2 00 97 cd 21 a6 07 9b e7 62 d1 03 05 ## [176] b7 26 1c 80 ff 5c 69 77 13 3e 8d 3c a1 27 30 35 44 c7 33 9d 55 f0 16 6e 57 ## [201] c3 2a 7e dc 97 a0 e5 c9 92 01 ef 49 90 1d 7a ad 45 57 36 ed b5 bd 7a 62 87 ## [226] 5d 4c 92 58 61 f0 75 e4 37 f1 77 d1 de 0a 5d c0 7e 13 22 a8 f9 63 f7 c7 60 ## [251] 88 f2 a9 a6 f5 d0 77 ce 04 f3 f9 07 f5 b6 2d 0b 87 a8 15 4d b1 9a 3e 3a e7 ## [276] 4c 7a 84 d4 4b 12 f1 6e b3 7c cd 15 7e 45 31 7e ef 2c b0 5f b9 55 13 48 e3 ## [301] 01 aa ae 06 c2 a9 dc fe 94 2d d1 1b 2f c7 d9 b7 fe b6 47 00 00 00 18 00 00 ## [326] 00 10 6b 46 ae 32 ed 9a f2 8a d0 f1 f0 fc 1c da ef 6c 00 00 00 18 00 00 01 ## [351] 00 b9 c3 f3 06 2a b3 44 e6 f9 bf c8 18 a3 fb cc c6 2f 91 1d fe 72 8d f4 67 ## [376] db a8 01 7a b4 c3 82 07 e4 b1 44 89 7b a5 44 73 9e f9 65 f6 27 a0 d4 ce c6 ## [401] 68 36 cf db 0a 81 2f 3d 0e 5e ed 0f 67 ab 68 40 7a aa 5f b5 fb ea 01 44 6d ## [426] d5 43 c0 51 20 38 63 a2 7b e9 26 ed eb 85 8e 01 ec fb 44 e7 4f 08 3f ac 89 ## [451] a5 82 8b 58 a5 d8 48 2b 28 7c df 1d a3 b1 4f 42 ce 51 66 7b f7 29 b5 1a 29 ## [476] f3 8b 7e de 5c e1 f6 c0 9d 80 00 e2 8a bd 20 bb 8f 27 e3 47 f0 d2 00 08 8d ## [501] d8 4b 12 4d bd 17 f3 b1 12 2c 1a 14 5e 3c 0a 3b 2e de 33 18 96 76 61 f8 66 ## [526] f8 69 75 39 fb 09 79 20 32 c5 b1 21 0e d3 df 86 f3 af 41 41 9f 27 26 f3 8d ## [551] af 80 fd 34 48 fe 0f b5 68 62 8e c7 e1 c1 25 f1 5f c6 e4 c3 c8 88 d4 51 1b ## [576] 59 f9 38 70 8c 72 1a bb af e8 71 21 df 88 04 27 8e 80 3c 83 aa 66 ef 9a f3 ## [601] 38 4a 10 4e 76 da e4 00 00 04 02 00 00 00 01 00 04 00 09 00 00 00 05 6e 61 ## [626] 6d 65 73 00 00 00 10 00 00 00 04 00 04 00 09 00 00 00 02 69 76 00 04 00 09 ## [651] 00 00 00 07 73 65 73 73 69 6f 6e 00 04 00 09 00 00 00 04 64 61 74 61 00 04 ## [676] 00 09 00 00 00 09 73 69 67 6e 61 74 75 72 65 00 00 00 fe cyphr::decrypt_string(secret, pair_a) ## Error in openssl::decrypt_envelope(x$data, x$iv, x$session, key): OpenSSL error: 0078E2D00B7F0000:error:03000082:digital envelope routines:EVP_CIPHER_CTX_set_key_length:invalid key length:../crypto/evp/evp_enc.c:1029: pair_b <- cyphr::keypair_openssl(path_key_alice, path_key_bob) cyphr::decrypt_string(secret, pair_b) ## [1] \"secret message\" secret2 <- cyphr::encrypt_string(\"another message\", pair_b) secret2 ##   [1] 58 0a 00 00 00 03 00 04 03 02 00 03 05 00 00 00 00 05 55 54 46 2d 38 00 00 ##  [26] 02 13 00 00 00 04 00 00 00 18 00 00 00 10 48 63 68 58 10 70 1d 4e 15 5a be ##  [51] 67 75 e6 e2 a3 00 00 00 18 00 00 01 00 9c 50 9d 19 0e 4f 4c ba c4 03 21 59 ##  [76] d8 48 3d 5b b9 af a0 9c 8b 40 2e a1 ce 3b cf 3f 48 77 29 e6 03 c4 9b 78 42 ## [101] 4f e8 82 38 7e c0 55 51 27 27 03 9d ff a5 ee c3 56 13 07 a7 98 a6 f0 72 45 ## [126] 04 b6 6b 81 c8 49 73 3f 37 4b 34 74 32 2c 35 f8 ba a8 27 6a 68 35 24 c8 56 ## [151] b1 eb a8 ce a4 6e 76 22 0b d6 b2 2f 06 15 f7 4d 25 3a 1d 36 81 9f 75 bd 64 ## [176] c4 de af 8d 8a 1f 2e 8b b6 4a f1 32 12 31 6e 15 26 18 c8 43 f5 db 84 c2 3d ## [201] da 7e ea 4e ad 90 02 88 23 ab d2 17 b6 28 d5 3b 30 ed 35 c9 e8 25 93 34 a4 ## [226] cc 50 8f 20 28 f8 62 7c bc 75 48 d2 ca 90 cb 73 21 df a0 e1 41 b3 6f 97 10 ## [251] 7f 06 bb fd 9b 21 ae d8 e7 93 8c e7 5b a2 45 79 0d e1 2d 2d 08 e1 c1 17 2c ## [276] 86 67 80 1d d4 44 bc 87 34 ca 45 d8 63 62 f9 fa 9e e5 14 0b b6 99 ec 12 b9 ## [301] 6f 06 d3 b4 1e f5 db 2d 6c 63 5c 62 af aa 79 79 a1 99 c2 00 00 00 18 00 00 ## [326] 00 10 8b 09 91 c9 e4 4e f6 06 92 0c 7a 32 74 df 5b 9c 00 00 00 18 00 00 01 ## [351] 00 13 1b c0 2e b2 75 14 73 d2 b3 a7 e3 3b cd 69 f0 bf d5 2d c3 52 6e d2 d3 ## [376] 13 ad d0 f6 97 1a 08 31 3c 47 00 22 7e 0f 2c ca be 22 5f d3 2d 43 14 4f 84 ## [401] e2 c8 48 8a db 10 9c 9e 68 93 b3 12 1a f2 f1 4e 27 26 68 7a 62 0f 4d 09 41 ## [426] 41 6f ab ff 87 48 46 7c 10 39 21 b8 de cf 7b 26 c2 d3 a9 3d 6f 2f 0c f8 81 ## [451] f1 ae bf d5 1a 3b a3 c9 65 b1 69 90 8d 1e fb f4 ce ab 6c 78 a9 6c d9 ba 65 ## [476] 4d 9c 29 bf ac 8f 42 4b 01 50 31 24 f4 f2 b9 1b a1 fe a4 ff 7b bf ef 60 7e ## [501] 6e 7e a2 1d a9 33 60 70 14 78 91 98 67 71 d2 8f f7 97 d3 fc 8d 5e 7e e8 95 ## [526] a7 7b b4 50 ec e6 f1 c6 77 d6 c4 27 38 ea b4 4d 5a ee 10 81 2a 5d 58 55 fe ## [551] a8 43 1d 65 59 ed 2b 8e 7d 6c 96 29 4e 20 bb 94 ac 9e 49 3f d8 a0 ab 04 58 ## [576] 05 0c bd 10 a6 b6 5b 82 82 6b 8a 5a df a7 e0 cd 3c 6f 53 fb d0 17 dd 72 62 ## [601] ee 5f c1 26 9e 19 6a 00 00 04 02 00 00 00 01 00 04 00 09 00 00 00 05 6e 61 ## [626] 6d 65 73 00 00 00 10 00 00 00 04 00 04 00 09 00 00 00 02 69 76 00 04 00 09 ## [651] 00 00 00 07 73 65 73 73 69 6f 6e 00 04 00 09 00 00 00 04 64 61 74 61 00 04 ## [676] 00 09 00 00 00 09 73 69 67 6e 61 74 75 72 65 00 00 00 fe cyphr::decrypt_string(secret2, pair_a) ## [1] \"another message\" pair_us <- cyphr::keypair_openssl(path_key_bob, NULL) secret <- cyphr::encrypt_string(\"secret message\", pair_a) path_for_bob <- file.path(tempdir(), \"for_bob_only\") writeBin(secret, path_for_bob) secret <- readBin(path_for_bob, raw(), file.size(path_for_bob)) cyphr::decrypt_string(secret, pair_b) ## [1] \"secret message\" secret_base64 <- openssl::base64_encode(secret) secret_base64 ## [1] \"WAoAAAADAAQDAgADBQAAAAAFVVRGLTgAAAITAAAABAAAABgAAAAQkW5oCfk1l+INnJo/TXUpbAAAABgAAAEAImgxzSVS8iNIbjl+ifAfCzoplhHq6VZ3l2SKXuhyeeMYffe0HkaOuteubOwQRONJoBCbTrqp0I02Y34gvpCDhIn38Q2OoJe3Yr4eq5Uy6wM17+KMpuQ8uLljtGNg76VAP3yhxs7byu9UiaH/URb069nrZbMocvfUmk68D3sssuqnjLrCm5JEi9S+ypHAod+XKB8kuDbO9QgL1t0dPf+AwmSsVX+7GBDM4lqeY2SMRWiP4m0bzy2gXLKm3sg8KJJKNqzdbM+fNX4kSkdlonHFQVTwHDZDyzHFoTl8YuuXTvjOKWvZ/CvSZWQHy0ufzqHD16lFu04ERXtUJgvSkASjwwAAABgAAAAQ0y9kupdE9Xy7NGULW9Z6JQAAABgAAAEAucPzBiqzROb5v8gYo/vMxi+RHf5yjfRn26gBerTDggfksUSJe6VEc575ZfYnoNTOxmg2z9sKgS89Dl7tD2eraEB6ql+1++oBRG3VQ8BRIDhjonvpJu3rhY4B7PtE508IP6yJpYKLWKXYSCsofN8do7FPQs5RZnv3KbUaKfOLft5c4fbAnYAA4oq9ILuPJ+NH8NIACI3YSxJNvRfzsRIsGhRePAo7Lt4zGJZ2Yfhm+Gl1OfsJeSAyxbEhDtPfhvOvQUGfJybzja+A/TRI/g+1aGKOx+HBJfFfxuTDyIjUURtZ+ThwjHIau6/ocSHfiAQnjoA8g6pm75rzOEoQTnba5AAABAIAAAABAAQACQAAAAVuYW1lcwAAABAAAAAEAAQACQAAAAJpdgAEAAkAAAAHc2Vzc2lvbgAEAAkAAAAEZGF0YQAEAAkAAAAJc2lnbmF0dXJlAAAA/g==\" identical(openssl::base64_decode(secret_base64), secret) ## [1] TRUE secret_hex <- sodium::bin2hex(secret) secret_hex ## [1] \"580a000000030004030200030500000000055554462d3800000213000000040000001800000010916e6809f93597e20d9c9a3f4d75296c0000001800000100226831cd2552f223486e397e89f01f0b3a299611eae9567797648a5ee87279e3187df7b41e468ebad7ae6cec1044e349a0109b4ebaa9d08d36637e20be90838489f7f10d8ea097b762be1eab9532eb0335efe28ca6e43cb8b963b46360efa5403f7ca1c6cedbcaef5489a1ff5116f4ebd9eb65b32872f7d49a4ebc0f7b2cb2eaa78cbac29b92448bd4beca91c0a1df97281f24b836cef5080bd6dd1d3dff80c264ac557fbb1810cce25a9e63648c45688fe26d1bcf2da05cb2a6dec83c28924a36acdd6ccf9f357e244a4765a271c54154f01c3643cb31c5a1397c62eb974ef8ce296bd9fc2bd2656407cb4b9fcea1c3d7a945bb4e04457b54260bd29004a3c30000001800000010d32f64ba9744f57cbb34650b5bd67a250000001800000100b9c3f3062ab344e6f9bfc818a3fbccc62f911dfe728df467dba8017ab4c38207e4b144897ba544739ef965f627a0d4cec66836cfdb0a812f3d0e5eed0f67ab68407aaa5fb5fbea01446dd543c051203863a27be926edeb858e01ecfb44e74f083fac89a5828b58a5d8482b287cdf1da3b14f42ce51667bf729b51a29f38b7ede5ce1f6c09d8000e28abd20bb8f27e347f0d200088dd84b124dbd17f3b1122c1a145e3c0a3b2ede3318967661f866f8697539fb09792032c5b1210ed3df86f3af41419f2726f38daf80fd3448fe0fb568628ec7e1c125f15fc6e4c3c888d4511b59f938708c721abbafe87121df8804278e803c83aa66ef9af3384a104e76dae4000004020000000100040009000000056e616d6573000000100000000400040009000000026976000400090000000773657373696f6e00040009000000046461746100040009000000097369676e6174757265000000fe\" identical(sodium::hex2bin(secret_hex), secret) ## [1] TRUE cyphr::keypair_openssl(NULL, NULL) cyphr::ssh_keygen(\"~/.ssh\")"},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"sodium-1","dir":"Articles","previous_headings":"Keys and the like > Asymmetric encryption (“key pairs”)","what":"sodium","title":"Introduction","text":"sodium, things largely exception standard format saving sodium keys. bits use -memory key (just collection bytes) can also filenames, contains contents key written writeBin. First, generate keys Alice: public key derived private key, Alice can share Bob. next generate Bob’s keys Bob now share public key Alice. Alice wants send message Bob uses private key Bob’s public key: , can now send message: Note line identical one openssl section. decrypt message, Bob use Alice’s public key private key:","code":"key_a <- sodium::keygen() pub_a <- sodium::pubkey(key_a) key_b <- sodium::keygen() pub_b <- sodium::pubkey(key_b) pair_a <- cyphr::keypair_sodium(pub_b, key_a) secret <- cyphr::encrypt_string(\"secret message\", pair_a) secret ##  [1] 57 df 99 a1 31 67 05 c4 c9 65 6a 17 c2 d3 d2 c5 11 13 6a c6 0c 7b 90 27 6a ## [26] 7b 03 4f 6d a6 a9 c9 00 1f 5d c0 a4 76 38 1a 37 15 8e a7 61 6a 53 95 6e 6c ## [51] 6a 58 27 97 pair_b <- cyphr::keypair_sodium(pub_a, key_b) cyphr::decrypt_string(secret, pair_b) ## [1] \"secret message\""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"encrypting-things","dir":"Articles","previous_headings":"","what":"Encrypting things","title":"Introduction","text":", used cyphr::encrypt_string cyphr::decrypt_string encrypt decrypt string. several functions package encrypt decrypt R objects encrypt_object / decrypt_object (using serialization deserialization) strings: encrypt_string / decrypt_string raw vectors: encrypt_data / decrypt_data files: encrypt_file / decrypt_file section just use sodium symmetric encryption key examples , case asymmetric encryption (using either cyphr::keypair_openssl cyphr::keypair_sodium) sender use private key recipient’s public key recipient use complementary key pair.","code":"key <- cyphr::key_sodium(sodium::keygen())"},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"objects","dir":"Articles","previous_headings":"Encrypting things","what":"Objects","title":"Introduction","text":"’s object encrypt: creates bunch raw bytes corresponding data (’s really possible print anything nicer bytes). data can decrypted decrypt_object function: Optionally, process can go via file, using third argument functions (note temporary files used compliance CRAN policies - path may used practice). now file called secret.rds temporary directory: though actually rds file: passed filename (opposed raw vector), cyphr::decrypt_object read object decrypting ","code":"obj <- list(x = 1:10, y = \"secret\") secret <- cyphr::encrypt_object(obj, key) secret ##   [1] fd d2 91 07 07 24 36 38 6f 70 77 09 f8 59 df 9c 67 da 3d 5d 95 c1 dc 7e 8b ##  [26] 3d 59 43 55 19 c0 bf b6 a0 f6 b8 a9 24 3f dc dd fe 28 16 38 a8 7f ef 82 ee ##  [51] 67 5b 2f 3e 03 2c ea 94 01 32 49 bb 16 19 10 70 92 23 c0 b9 13 38 4b 2f 63 ##  [76] 75 5a 0e fb b4 22 ee c0 d4 0c af 5c 6b c8 ea 5c ed 05 e3 7a 8c 8a 79 86 fe ## [101] 3d 9a c4 19 60 93 27 00 36 2f 56 ec 17 10 35 18 84 6e b1 8e 74 08 1d b7 3c ## [126] d4 18 ac 18 c3 6e 1e ea c5 00 d7 cd c3 10 49 36 24 a3 5a d2 ca 7f ce 11 65 ## [151] 60 20 24 49 0c e6 87 e3 6e 57 6f e4 60 f1 7f 95 df c4 33 84 6e 4a 3c 5c e3 ## [176] 2d 96 dd 56 99 fc e3 65 bb 5a 5e e8 24 86 23 18 12 25 69 77 22 dd 1d 72 34 ## [201] 09 1a 51 f1 12 af 85 8d 0d a8 7e 5d ea a8 bb fd 57 b1 cc b9 b6 32 64 79 4d ## [226] 58 e8 2c 99 8e 5d de 61 f7 19 a1 05 25 f4 93 48 f7 81 2f d9 4b 21 9a 57 5a ## [251] bb 7b ec 22 cyphr::decrypt_object(secret, key) ## $x ##  [1]  1  2  3  4  5  6  7  8  9 10 ##  ## $y ## [1] \"secret\" path_secret <- file.path(tempdir(), \"secret.rds\") cyphr::encrypt_object(obj, key, path_secret) file.exists(path_secret) ## [1] TRUE readRDS(path_secret) ## Error in readRDS(path_secret): unknown input format cyphr::decrypt_object(path_secret, key) ## $x ##  [1]  1  2  3  4  5  6  7  8  9 10 ##  ## $y ## [1] \"secret\""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"strings","dir":"Articles","previous_headings":"Encrypting things","what":"Strings","title":"Introduction","text":"case strings can slightly lightweight way (function routes serialize / deserialize can slow create larger objects using charToRaw / rawToChar) decrypt:","code":"secret <- cyphr::encrypt_string(\"secret\", key) secret ##  [1] 0e 1a ad fb 9b 54 b5 b8 4c cb 7a 93 c5 56 bf 21 d0 ce 38 33 17 9b 54 47 21 ## [26] b1 17 3c 7e 1d 5c c4 43 0a 98 01 0b 11 20 30 15 ed d8 f5 05 59 cyphr::decrypt_string(secret, key) ## [1] \"secret\""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"plain-raw-data","dir":"Articles","previous_headings":"Encrypting things","what":"Plain raw data","title":"Introduction","text":"enough , can work directly raw objects (bunches bytes) using encrypt_data: Decrypted data original data","code":"dat <- sodium::random(100) dat # some random bytes ##   [1] bf 98 3e 14 c7 d8 f6 dc 70 70 48 db d5 6f de fd 4e 98 85 bc 3a 8e 50 31 b5 ##  [26] 55 62 83 b7 2b 47 20 cf 3e 86 cf a9 38 99 7e 3e 1b 41 29 c4 90 e8 fc f6 49 ##  [51] 85 e1 fa 58 91 79 77 08 9f 3f a6 09 c6 47 17 30 07 1e 7d 93 6c ae 3b 9e de ##  [76] 74 56 05 e8 4b 7e 11 b6 7d ec d2 e8 53 4d 6f 1c 9c 31 37 54 3a e2 84 98 18 secret <- cyphr::encrypt_data(dat, key) secret ##   [1] 9e 34 cb 1d 69 71 05 39 b2 30 f2 1f 00 d4 40 b9 1f d0 57 db fe 99 be 8f 6c ##  [26] a3 3e 1b 66 53 2a 3f 30 d6 a9 25 5a f2 c1 cf 92 f3 0f 96 72 d3 d7 72 70 8a ##  [51] 68 b9 6d 6b b2 1a ac c8 15 69 64 3c f1 ef a2 88 9a 0d eb ef 12 1b 2b 4c cf ##  [76] 91 11 ea a3 3c 42 25 23 ca 18 51 8b 94 43 62 01 b3 e6 6f 47 20 51 d5 74 bc ## [101] d0 3a 33 02 63 2a 00 aa bc b1 bf 8e f1 dc 3b e9 e5 41 ea 6d f8 25 70 8d 1d ## [126] 0a 2d 1f 65 66 04 ca 08 a5 48 9f 5a 3d e3 1d identical(cyphr::decrypt_data(secret, key), dat) ## [1] TRUE"},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"files","dir":"Articles","previous_headings":"Encrypting things","what":"Files","title":"Introduction","text":"Suppose written file want encrypt send someone (temporary directory compliance CRAN policies) can encrypt file encrypted file can decrypted identical original:","code":"path_data_csv <- file.path(tempdir(), \"iris.csv\") write.csv(iris, path_data_csv, row.names = FALSE) path_data_enc <- file.path(tempdir(), \"iris.csv.enc\") cyphr::encrypt_file(path_data_csv, key, path_data_enc) path_data_decrypted <- file.path(tempdir(), \"idis2.csv\") cyphr::decrypt_file(path_data_enc, key, path_data_decrypted) tools::md5sum(c(path_data_csv, path_data_decrypted)) ##           /tmp/RtmpZLZLdL/iris.csv          /tmp/RtmpZLZLdL/idis2.csv  ## \"5fe92fe6a2c1928ef5a67b8939fdaf8d\" \"5fe92fe6a2c1928ef5a67b8939fdaf8d\""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"an-even-higher-level-interface-for-files","dir":"Articles","previous_headings":"","what":"An even higher level interface for files","title":"Introduction","text":"user-friendly way using package aim encrypt decrypt files. package provides pair functions cyphr::encrypt cyphr::decrypt wrap file writing file reading functions. general use encrypt writing file decrypt reading one. ’re designed used like : Suppose super-secret object want share privately save x disk saveRDS readable everyone deleted. encrypted file saveRDS produced protected people key can read : (see details works). file read readRDS: wrap call decrypt pass config object can decrypted read: happens call cyphr uses “non standard evaluation” rewrite call becomes (approximately) use cyphr::decrypt_file decrypt “secret.rds” temporary file call readRDS temporary file delete temporary file (even error calls) non-standard evaluation breaks referential integrity (may suitable programming). can always manually encrypt_file / decrypt_file long make sure clean . encrypt function inspects call first argument passed works function provided (saveRDS) argument corresponds filename (\"secret.rds\"). rewrites call write temporary file (using tempfile()). calls encrypt_file (see ) temporary file create file asked (\"secret.rds\"). deletes temporary file, though also happen case error . decrypt function works similarly. inspects call detects first argument represents filename. decrypts file create temporary file, runs readRDS file. delete temporary file exit. functions supported via interface : readLines / writeLines readRDS / writeRDS read / save read.table / write.table read.csv / read.csv2 / write.csv read.delim / read.delim2 new functions can added rewrite_register function. example, support excellent rio package, whose import export functions take filename file use: now can read write tabular data great many different file formats encryption calls like functions use non standard evaluation may suitable programming use packages. “escape hatch” provided via encrypt_ decrypt_ first argument quoted expression.","code":"key <- cyphr::key_sodium(sodium::keygen()) x <- list(a = 1:10, b = \"don't tell anyone else\") path_object <- file.path(tempdir(), \"secret.rds\") cyphr::encrypt(saveRDS(x, path_object), key) readRDS(path_object) ## Error in readRDS(path_object): unknown input format cyphr::decrypt(readRDS(path_object), key) ## $a ##  [1]  1  2  3  4  5  6  7  8  9 10 ##  ## $b ## [1] \"don't tell anyone else\" cyphr::rewrite_register(\"rio\", \"import\", \"file\") cyphr::rewrite_register(\"rio\", \"export\", \"file\") cyphr::encrypt(rio::export(mtcars, \"file.json\"), key) cyphr::decrypt(rio::import(\"file.json\"), key) cyphr::encrypt_(quote(saveRDS(x, path_object)), key) cyphr::decrypt_(quote(readRDS(path_object)), key) ## $a ##  [1]  1  2  3  4  5  6  7  8  9 10 ##  ## $b ## [1] \"don't tell anyone else\""},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"session-keys","dir":"Articles","previous_headings":"","what":"Session keys","title":"Introduction","text":"using key_openssl, keypair_openssl, key_sodium, keypair_sodium generate something can decrypt data. objects returned functions can encrypt decrypt data reasonable concerned objects saved disk data compromised. avoid , cyphr store private symmetric keys directly objects instead encrypts sensitive keys cyphr-specific session key regenerated time package loaded. means objects practically useful within one session, saved save.image (perhaps automatically end session) keys used decrypt data. manually invalidate keys can use cyphr::session_key_refresh function. example, symmetric key: can use encrypt secret string decrypt : refresh session key invalidate key object point key used approach works package holds session key within environment (cyphr:::session$key) R serialize. noted - approach prevent attacker ability snoop R session discovering private keys sensitive data prevent accidentally saving keys way useful attacker use subsequent session.","code":"key <- cyphr::key_sodium(sodium::keygen()) secret <- cyphr::encrypt_string(\"my secret\", key) cyphr::decrypt_string(secret, key) ## [1] \"my secret\" cyphr::session_key_refresh() cyphr::decrypt_string(secret, key) ## Error: Failed to decrypt key as session key has changed"},{"path":"https://docs.ropensci.org/cyphr/articles/cyphr.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further reading","title":"Introduction","text":"wikipedia page Public Key cryptography nice diagrams explain key data interact https://en.wikipedia.org/wiki/Public-key_cryptography vignettes openssl (vignette(package = \"openssl\")) sodium (vignette(package = \"openssl\")) packages explanations tools used cyphr work interface R. Confused? Need help? Found bug? Post issue cyphr issue tracker Start discussion rOpenSci discussion forum","code":""},{"path":"https://docs.ropensci.org/cyphr/articles/data.html","id":"minimal-example","dir":"Articles","previous_headings":"","what":"Minimal example","title":"Data Encryption","text":", less discussion: Setup, Alice’s computer: Get data key key: Encrypt file: Request access, Bob’s computer: Alice authorises request:: Bob can get data key: Bob can read secret data:","code":"cyphr::data_admin_init(data_dir, path_user = path_key_alice) ## Generating data key ## Authorising ourselves ## Adding key 33:69:2f:4b:b3:9a:23:d5:fe:f0:e0:e6:a9:8e:2c:ce:91:b1:a3:f0:89:65:54:b0:32:5f:6e:d1:5a:54:1b:5e ##   user: root ##   host: 8d8641327ce4 ##   date: 2024-03-18 05:40:11.960834 ## Verifying key <- cyphr::data_key(data_dir, path_user = path_key_alice) cyphr::encrypt(saveRDS(iris, filename), key) hash <- cyphr::data_request_access(data_dir, path_user = path_key_bob) ## A request has been added ## Email someone with access to add you ##  ##     hash: 4c:ed:14:00:77:4b:47:a9:5a:cc:8a:2f:ef:bb:66:ae:64:2c:bb:e5:f7:ca:05:20:fb:ab:4c:49:60:0c:cb:2a ##  ## If you are using git, you will need to commit and push first: ##  ##     git add .cyphr ##     git commit -m \"Please add me to the dataset\" ##     git push cyphr::data_admin_authorise(data_dir, yes = TRUE, path_user = path_key_alice) ## There is 1 request for access ## Adding key 4c:ed:14:00:77:4b:47:a9:5a:cc:8a:2f:ef:bb:66:ae:64:2c:bb:e5:f7:ca:05:20:fb:ab:4c:49:60:0c:cb:2a ##   user: root ##   host: 8d8641327ce4 ##   date: 2024-03-18 05:40:12.161059 ## Added 1 key ## If you are using git, you will need to commit and push: ##  ##     git add .cyphr ##     git commit -m \"Authorised root\" ##     git push key <- cyphr::data_key(data_dir, path_user = path_key_bob) head(cyphr::decrypt(readRDS(filename), key)) ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1          5.1         3.5          1.4         0.2  setosa ## 2          4.9         3.0          1.4         0.2  setosa ## 3          4.7         3.2          1.3         0.2  setosa ## 4          4.6         3.1          1.5         0.2  setosa ## 5          5.0         3.6          1.4         0.2  setosa ## 6          5.4         3.9          1.7         0.4  setosa"},{"path":"https://docs.ropensci.org/cyphr/articles/data.html","id":"details-disclosure","dir":"Articles","previous_headings":"","what":"Details & disclosure","title":"Data Encryption","text":"Encryption work security obscurity; works can rely underlying maths enough open things stored . encryption libraries require degree security underlying software. way R works difficult guarantee; trivial rewrite code running packages skip past verification checks. package designed (able ) avoid exploits running code; attacker intercept private keys, private key data, skip verification checks used make sure keys load say . However, data safe; people keys data able read . cyphr uses two different encryption algorithms; uses RSA encryption via openssl package user keys, common file format keys makes user configuration easier. uses modern sodium package (libsodium library) data encryption fast simple work . leave two possible points weakness vulnerability either libraries lead exploit allow decryption data. user public/private key pair. Typically ~/.ssh/id_rsa.pub ~/.ssh/id_rsa, found used. Alternatively location keypair can stored elsewhere pointed USER_KEY USER_PUBKEY environment variables. key may password protected (recommended!) password requested without ever echoing terminal. data directory hidden directory .cyphr . actually need stored data makes sense (workflows data stored remotely storing directory might make sense). “keys” directory contains number files; one person access data. (file test small file encrypted data key used verify everything working OK). file stored RDS format list elements: user: reported user name person created request data host: reported computer name date: time request generated pub: RSA public key user key: data key, encrypted user key. Without private key, used. user’s private key can used generate symmetric key data. can see hash public key name stored file (used prevent collisions multiple people request access time). request posted RDS file except key element, added authorisation. (Note verification relies package code attacked, given R’s highly dynamic nature attacker easily swap definition verification function something always returns TRUE.) authorised user creates data_key object (allows decryption data) secret : read private user key (probably ~/.ssh/id_rsa) read encrypted data key data directory ($key element list ). decrypt data key using user key yield data symmetric key.","code":"dir(data_dir, all.files = TRUE, no.. = TRUE) ## [1] \".cyphr\"   \"iris.rds\" dir(file.path(data_dir, \".cyphr\", \"keys\")) ## [1] \"33692f4bb39a23d5fef0e0e6a98e2cce91b1a3f0896554b0325f6ed15a541b5e\" ## [2] \"4ced1400774b47a95acc8a2fefbb66ae642cbbe5f7ca0520fbab4c49600ccb2a\" names(cyphr::data_admin_list_keys(data_dir)) ## [1] \"33692f4bb39a23d5fef0e0e6a98e2cce91b1a3f0896554b0325f6ed15a541b5e\" ## [2] \"4ced1400774b47a95acc8a2fefbb66ae642cbbe5f7ca0520fbab4c49600ccb2a\" h <- names(cyphr::data_admin_list_keys(data_dir))[[1]] readRDS(file.path(data_dir, \".cyphr\", \"keys\", h)) ## $user ## [1] \"root\" ##  ## $host ## [1] \"8d8641327ce4\" ##  ## $date ## [1] \"2024-03-18 05:40:11 UTC\" ##  ## $pub ## [2048-bit rsa public key] ## md5: b5f2de69993b7bb18267822463a7c9ec ## sha256: 33692f4bb39a23d5fef0e0e6a98e2cce91b1a3f0896554b0325f6ed15a541b5e ##  ## $key ##   [1] ae 07 d5 ff 3b c8 b6 40 51 45 73 13 76 19 27 4e 0f f6 eb c2 05 d2 a7 d4 b5 ##  [26] 07 0c 13 8f 97 e5 6f 08 82 e0 96 f5 6f 57 c5 10 3a bb 79 73 96 a9 48 a2 bd ##  [51] 6e 50 34 f6 b6 16 ec 33 8d 4a fd 15 d6 64 51 6b 18 d9 04 68 9f da 4d b1 c4 ##  [76] a1 57 b5 65 30 10 cf 99 f3 50 21 8c 8a 85 0c e1 6f 34 7b 70 32 34 f7 4f 73 ## [101] aa e7 08 67 9a dd 8d c2 42 fb 93 8d 11 77 27 4b 82 64 ea 46 63 a6 6d af 5f ## [126] 95 0c 32 80 8c 53 40 ae ed c7 12 e0 4a df b4 a8 f9 d7 e8 d7 5a 58 c7 10 b9 ## [151] 1e d5 62 8c e1 0c a8 25 e5 84 a8 61 66 44 03 19 a7 c9 7d be bb 1f fc 69 44 ## [176] 33 e0 24 f9 f5 98 8b 92 4a 40 dd 70 81 53 cd 06 06 38 d1 05 10 51 68 17 db ## [201] ee a9 11 2c 7b 7a 26 0b d2 84 db 18 19 7c d2 a0 ce f2 08 9b 6e 52 cf 9c 2d ## [226] 4a bd 13 ab 08 74 4c 2f 6e 6e c4 93 7a ef cc 4f 51 11 6a 35 09 60 5a 74 91 ## [251] d8 a1 10 35 09 cb h ## [1] \"33692f4bb39a23d5fef0e0e6a98e2cce91b1a3f0896554b0325f6ed15a541b5e\""},{"path":"https://docs.ropensci.org/cyphr/articles/data.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Data Encryption","text":"Dropbox scenario, non-password protected keys afford limited protection. even though keys data stored separately Dropbox, place local computer; computer lost thing preventing attacker recovering data security obscurity (data appear random junk able run analysis scripts easily can). Password protected keys improve situation considerably without password data recovered. data encrypted running R session. R allows arbitrary modification code runtime package provides security point data can decrypted. computer compromised stealing data running R assumed straightforward.","code":""},{"path":"https://docs.ropensci.org/cyphr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rich FitzJohn. Author, maintainer. Jai Ranganathan. Contributor.","code":""},{"path":"https://docs.ropensci.org/cyphr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"FitzJohn R (2024). cyphr: High Level Encryption Wrappers. R package version 1.1.5, https://docs.ropensci.org/cyphr/, https://github.com/ropensci/cyphr.","code":"@Manual{,   title = {cyphr: High Level Encryption Wrappers},   author = {Rich FitzJohn},   year = {2024},   note = {R package version 1.1.5, https://docs.ropensci.org/cyphr/},   url = {https://github.com/ropensci/cyphr}, }"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"cyphr","dir":"","previous_headings":"","what":"High Level Encryption Wrappers","title":"High Level Encryption Wrappers","text":"High-level functions supporting encryption decryption data R. allows secure storage exchange information, trying keep encryption/decryption code taking analyses. cyphr wraps lower-level support sodium openssl. package designed easy use, rather secure thing (’re using R, remember - examples cyphr can’t protect see jammr, rpwnd evil.R.) cyphr provides high level functions : strings: encrypt_string / decrypt_string objects: encrypt_object / decrypt_object raw data: encrypt_data / decrypt_data files: encrypt_file / decrypt_file User-friendly wrappers (encrypt decrypt) around R’s file reading writing functions enable transparent encryption (support included readRDS/writeRDS, read.csv/write.csv, etc). package aims make encrypting decrypting easy addition, package implements workflow allows group securely share data encrypting shared (“symmetric”) key turn encrypted users ssh keys. use case group researchers collaborating dataset made public, example containing sensitive data. However, decided need store setting 100% confident security data. encrypt data read/write.","code":"cyphr::encrypt(save.csv(dat, \"file.csv\"), key) dat <- cyphr::decrypt(read.csv(\"file.csv\", stringsAsFactors = FALSE), key)"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"High Level Encryption Wrappers","text":"Install cyphr CRAN install development version github, can use remotes install cyphr github:","code":"install.packages(\"cyphr\") remotes::install_github(\"ropensci/cyphr\", upgrade = FALSE)"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"High Level Encryption Wrappers","text":"scope package protect data saved disk. designed stop attacker targeting R process determine contents sensitive data. package try prevent accidentally saving disk contents sensitive information, including keys decrypt information.","code":""},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"objects-to-handle-keys","dir":"","previous_headings":"","what":"Objects to handle keys:","title":"High Level Encryption Wrappers","text":"Decide style encryption create key object key_sodium: Symmetric encryption, using sodium – everyone shares key (must kept secret!) can encrypt decrypt data . used building block inflexible need keep key secret. key_openssl: Symmetric encryption using openssl keypair_sodium: Public key encryption sodium – lets people encrypt messages using public key can read using private key. keypair_openssl: Public key encryption, using openssl, big advantage many people already compatible (ssh) keys standard places standard file formats (see ?encrypt_envelope openssl package). cyphr include wrappers key generation sodium - sodium keys file format: secret symmetric key sodium might : key can create key_sodium object: key saved file work : load password protected ssh key prompted passphrase. cyphr ensure echoed onto console.","code":"k <- sodium::keygen() k ##  [1] 48 35 a2 6c 05 27 65 75 cb 08 01 de 76 8f 71 fe 3f d7 e4 7a df bf d8 e7 08 ## [26] d5 fb e9 61 c8 5f d1 key <- cyphr::key_sodium(k) key ## <cyphr_key: sodium> key <- cyphr::key_openssl() ## Please enter private key passphrase: key"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"encrypt--decrypt-a-file","dir":"","previous_headings":"","what":"Encrypt / decrypt a file","title":"High Level Encryption Wrappers","text":"files already exist want encrypt decrypt, functions cyphr::encrypt_file cyphr::decrypt_file (workhorse functions used internally throughout package) file encrypted now: Decrypt file read :","code":"saveRDS(iris, \"myfile\") cyphr::encrypt_file(\"myfile\", key, \"myfile.encrypted\") readRDS(\"myfile.encrypted\") ## Error in readRDS(\"myfile.encrypted\"): unknown input format cyphr::decrypt_file(\"myfile.encrypted\", key, \"myfile.clear\") identical(readRDS(\"myfile.clear\"), iris) ## [1] TRUE"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"wrappers-around-rs-file-functions","dir":"","previous_headings":"","what":"Wrappers around R’s file functions","title":"High Level Encryption Wrappers","text":"Encrypting files like risks leaving cleartext (.e., unencrypted) version around. want wrap output something like write.csv saveRDS really choice write file first, encrypt , delete clear version. Making sure happens even step fails error prone takes surprising number repetitive lines code. Alternatively, encrypt output file producing command, just wrap cyphr::encrypt decrypt file feed file consuming command, wrap cyphr::decrypt round-trip preserves data: without key, read: commands work computing language, rewriting readRDS saveRDS commands. Commands reading writing tabular plain text files (read.csv, readLines, etc) also supported, way rewriting done designed extensible. argument wrapped functions can connection objects. case actual command written file contents file encrypted written connection. reading/writing multiple objects /single connection though, likely go badly.","code":"cyphr::encrypt(saveRDS(iris, \"myfile.rds\"), key) dat <- cyphr::decrypt(readRDS(\"myfile.rds\"), key) identical(dat, iris) # yay ## [1] TRUE readRDS(\"myfile.rds\") ## Error in readRDS(\"myfile.rds\"): unknown input format"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"supporting-additional-functions","dir":"","previous_headings":"Wrappers around R’s file functions","what":"Supporting additional functions","title":"High Level Encryption Wrappers","text":"functions supported far : readLines / writeLines readRDS / writeRDS read / save read.table / write.table read.csv / read.csv2 / write.csv read.delim / read.delim2 However, bound functions useful add (e.g., readxl::read_excel). Either pass name file argument cyphr::encrypt / cyphr::decrypt register function package using rewrite_register: can use decrypt file (equivalent, former likely convenient ’re dealing couple files, latter convenient dealing many).","code":"cyphr::decrypt(readxl::read_excel(\"myfile.xlsx\"), key, file_arg = \"path\") cyphr::rewrite_register(\"readxl\", \"read_excel\", \"path\") cyphr::decrypt(readxl::read_excel(\"myfile.xlsx\"), key)"},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"collaborating-with-encrypted-data","dir":"","previous_headings":"","what":"Collaborating with encrypted data","title":"High Level Encryption Wrappers","text":"Even high-level functions ease encrypting decrypting things given key, work done distribute set keys across group people working together everyone can encrypt decrypt data keys compromised. package contains support group people working sensitive data set. data stored symmetric key. However, never actually store key directly, instead ’ll store copy user encrypted user’s key. user access data can authorise another user access data. described detail vignette (R: vignette(\"data\", package = \"cyphr\")).","code":""},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"why-are-wrappers-needed","dir":"","previous_headings":"","what":"Why are wrappers needed?","title":"High Level Encryption Wrappers","text":"low level functions sodium openssl work raw data, generality. users encounter raw vectors typical use R, require serialisation. encryption involves little extra random data (“nonce” sodium similar additional pieces openssl). need storing data, separating data decryption happens.","code":""},{"path":"https://docs.ropensci.org/cyphr/index.html","id":"licence","dir":"","previous_headings":"","what":"Licence","title":"High Level Encryption Wrappers","text":"MIT © Rich FitzJohn. Please note project released Contributor Code Conduct. participating project agree abide terms.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/cyphr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"High Level Encryption Wrappers — cyphr-package","title":"High Level Encryption Wrappers — cyphr-package","text":"Encryption wrappers, using low-level support sodium openssl.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/cyphr-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"High Level Encryption Wrappers — cyphr-package","text":"strongly recommended read vignettes attempting use cyphr. introduction; R: vignette(\"cyphr\", package = \"cyphr\") data vignette; R: vignette(\"data\", package = \"cyphr\")","code":""},{"path":[]},{"path":"https://docs.ropensci.org/cyphr/reference/cyphr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"High Level Encryption Wrappers — cyphr-package","text":"Rich FitzJohn (rich.fitzjohn@gmail.com)","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/data_admin.html","id":null,"dir":"Reference","previous_headings":"","what":"Encrypted data administration — data_admin_init","title":"Encrypted data administration — data_admin_init","text":"Encrypted data administration; functions setting , adding users, etc.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/data_admin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Encrypted data administration — data_admin_init","text":"","code":"data_admin_init(path_data, path_user = NULL, quiet = FALSE)  data_admin_authorise(   path_data = NULL,   hash = NULL,   path_user = NULL,   yes = FALSE,   quiet = FALSE )  data_admin_list_requests(path_data = NULL)  data_admin_list_keys(path_data = NULL)"},{"path":"https://docs.ropensci.org/cyphr/reference/data_admin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Encrypted data administration — data_admin_init","text":"path_data Path data set.  store bunch things hidden directory within path.  default functions search tree find .cyphr directory path_user Path directory ssh key. Usually can omitted. quiet Suppress printing informative messages. hash vector hashes add.  provided, hash can binary string representation hash add.  omit add request. yes Skip confirmation prompt?  request declined function throw error exit.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/data_admin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Encrypted data administration — data_admin_init","text":"data_admin_init initialises system; create data key exist authorise .  already exists access throw error. data_admin_authorise authorises key creating key data user can use conjunction personal key. data_admin_list_requests lists current requests. data_admin_list_keys lists known keys can access data.  Note secure; keys listed may still able access data (key authorised moved elsewhere example).  Conversely, user deleted changed key able access data despite key listed .","code":""},{"path":[]},{"path":"https://docs.ropensci.org/cyphr/reference/data_admin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Encrypted data administration — data_admin_init","text":"","code":"# The workflow here does not really lend itself to an example, # please see the vignette instead.  # First we need a set of user ssh keys.  In a non example # environment your personal ssh keys will probably work well, but # hopefully they are password protected so cannot be used in # examples.  The password = FALSE argument is only for testing, # and should not be used for data that you care about. path_ssh_key <- tempfile() cyphr::ssh_keygen(path_ssh_key, password = FALSE)  # Initialise the data directory, using this key path.  Ordinarily # the path_user argument would not be needed because we would be # using your user ssh keys: path_data <- tempfile() dir.create(path_data, FALSE, TRUE) cyphr::data_admin_init(path_data, path_user = path_ssh_key) #> Generating data key #> Authorising ourselves #> Adding key 99:ef:cc:42:73:ee:e0:de:10:20:61:f8:f0:ba:68:a3:93:1d:cb:e4:cc:64:72:11:bd:e4:ef:6e:f9:81:a1:98 #>   user: root #>   host: 8d8641327ce4 #>   date: 2024-03-18 05:40:00.609413 #> Verifying  # Now you can get the data key key <- cyphr::data_key(path_data, path_user = path_ssh_key)  # And encrypt things with it cyphr::encrypt_string(\"hello\", key) #>  [1] 7c 0d 0e 71 86 a4 9d 5b 3e df 16 fd 58 cf d0 bf 96 e7 c5 bc bb 87 51 40 54 #> [26] 54 04 d3 a4 a1 33 ac d4 f3 5a bb 6f 5e 25 0a 6b e1 14 09 19  # See the vignette for more details.  This is not the best medium # to explore this.  # Cleanup unlink(path_ssh_key, recursive = TRUE) unlink(path_data, recursive = TRUE)"},{"path":"https://docs.ropensci.org/cyphr/reference/data_user.html","id":null,"dir":"Reference","previous_headings":"","what":"User commands — data_request_access","title":"User commands — data_request_access","text":"User commands","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/data_user.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"User commands — data_request_access","text":"","code":"data_request_access(path_data = NULL, path_user = NULL, quiet = FALSE)  data_key(   path_data = NULL,   path_user = NULL,   test = TRUE,   quiet = FALSE,   cache = TRUE )"},{"path":"https://docs.ropensci.org/cyphr/reference/data_user.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"User commands — data_request_access","text":"path_data Path data.  given, look recursively working directory \".cyphr\" directory, use data directory. path_user Path directory user key. Usually can omitted.  argument passed pub key keypair_openssl(). Briefly, argument given look environment variables USER_PUBKEY USER_KEY - set must refer path public private keys.  environment variables set fall back ~/.ssh/id_rsa.pub ~/.ssh/id_rsa, work environments.  Alternatively, provide path directory file id_rsa.pub id_rsa can found. quiet Suppress printing informative messages. test Test encryption working?  (Recommended) cache Cache key within session.  useful using ssh keys passwords, key found within cache, re-enter password.  Using cache = FALSE neither looks key cache, saves .","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/data_user.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"User commands — data_request_access","text":"","code":"# The workflow here does not really lend itself to an example, # please see the vignette.  # Suppose that Alice has created a data directory: path_alice <- tempfile() cyphr::ssh_keygen(path_alice, password = FALSE) path_data <- tempfile() dir.create(path_data, FALSE, TRUE) cyphr::data_admin_init(path_data, path_user = path_alice) #> Generating data key #> Authorising ourselves #> Adding key ef:22:7b:6e:19:78:d3:69:74:f8:dd:59:7e:a8:65:79:6e:62:00:ef:9c:4e:5b:22:81:97:aa:f8:dc:1f:04:49 #>   user: root #>   host: 8d8641327ce4 #>   date: 2024-03-18 05:40:00.985033 #> Verifying  # If Bob can also write to the data directory (e.g., it is a # shared git repo, on a shared drive, etc), then he can request # access path_bob <- tempfile() cyphr::ssh_keygen(path_bob, password = FALSE) hash <- cyphr::data_request_access(path_data, path_user = path_bob) #> A request has been added #> Email someone with access to add you #>  #>     hash: 06:03:02:d7:f0:f0:19:46:e4:94:78:b4:d2:dc:df:82:b5:d7:44:fa:95:68:85:c9:c2:82:f7:32:31:15:1b:ff #>  #> If you are using git, you will need to commit and push first: #>  #>     git add .cyphr #>     git commit -m \"Please add me to the dataset\" #>     git push  # Alice can authorise Bob cyphr::data_admin_authorise(path_data, path_user = path_alice, yes = TRUE) #> There is 1 request for access #> Adding key 06:03:02:d7:f0:f0:19:46:e4:94:78:b4:d2:dc:df:82:b5:d7:44:fa:95:68:85:c9:c2:82:f7:32:31:15:1b:ff #>   user: root #>   host: 8d8641327ce4 #>   date: 2024-03-18 05:40:01.065081 #> Added 1 key #> If you are using git, you will need to commit and push: #>  #>     git add .cyphr #>     git commit -m \"Authorised root\" #>     git push  # After which Bob can get the data key cyphr::data_key(path_data, path_user = path_bob) #> <cyphr_key: sodium>  # See the vignette for more details.  This is not the best medium # to explore this.  # Cleanup unlink(path_alice, recursive = TRUE) unlink(path_bob, recursive = TRUE) unlink(path_data, recursive = TRUE)"},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt.html","id":null,"dir":"Reference","previous_headings":"","what":"Easy encryption and decryption — encrypt","title":"Easy encryption and decryption — encrypt","text":"Wrapper functions encryption.  functions wrap expressions produce consume file arrange encrypt (producing functions) decrypt (consuming functions). forms trailing underscore (encrypt_, decrypt_) use non-standard evaluation may useful programming.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Easy encryption and decryption — encrypt","text":"","code":"encrypt(expr, key, file_arg = NULL, envir = parent.frame())  decrypt(expr, key, file_arg = NULL, envir = parent.frame())  encrypt_(expr, key, file_arg = NULL, envir = parent.frame())  decrypt_(expr, key, file_arg = NULL, envir = parent.frame())"},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Easy encryption and decryption — encrypt","text":"expr single expression representing function call called side effect creating reading file. key cyphr_key object describing encryption approach use. file_arg Optional hint indicating argument expr filename.  done automatically built-functions. envir Environment expr evaluated.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Easy encryption and decryption — encrypt","text":"functions work functions.  example pdf/dev.create file wrap (yet!).  Functions modify file (e.g., appending) also work may cause data loss.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Easy encryption and decryption — encrypt","text":"","code":"# To do anything we first need a key: key <- cyphr::key_sodium(sodium::keygen())  # Encrypted write.csv - note how any number of arguments to # write.csv will be passed along path <- tempfile(fileext = \".csv\") cyphr::encrypt(write.csv(iris, path, row.names = FALSE), key)  # The new file now exists, but you would not be able to read it # with read.csv because it is now binary data. file.exists(path) #> [1] TRUE  # Wrap the read.csv call with cyphr::decrypt() dat <- cyphr::decrypt(read.csv(path, stringsAsFactors = FALSE), key) head(dat) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1          5.1         3.5          1.4         0.2  setosa #> 2          4.9         3.0          1.4         0.2  setosa #> 3          4.7         3.2          1.3         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 5          5.0         3.6          1.4         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa  file.remove(path) #> [1] TRUE  # If you have a function that is not supported you can specify the # filename argument directly.  For example, with \"write.dcf\" the # filename argument is called \"file\"; we can pass that along path <- tempfile() cyphr::encrypt(write.dcf(list(a = 1), path), key, file_arg = \"file\")  # Similarly for decryption: cyphr::decrypt(read.dcf(path), key, file_arg = \"file\") #>      a   #> [1,] \"1\""},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Encrypt and decrypt data and other things — encrypt_data","title":"Encrypt and decrypt data and other things — encrypt_data","text":"Encrypt decrypt raw data, objects, strings files.  core functions encrypt_data decrypt_data take raw data decrypt , writing either file returning raw vector.  functions encrypt decrypt arbitrary R objects (encrypt_object, decrypt_object), strings (encrypt_string, decrypt_string) files (encrypt_file, decrypt_file).","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Encrypt and decrypt data and other things — encrypt_data","text":"","code":"encrypt_data(data, key, dest = NULL)  encrypt_object(object, key, dest = NULL, rds_version = NULL)  encrypt_string(string, key, dest = NULL)  encrypt_file(path, key, dest = NULL)  decrypt_data(data, key, dest = NULL)  decrypt_object(data, key)  decrypt_string(data, key)  decrypt_file(path, key, dest = NULL)"},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Encrypt and decrypt data and other things — encrypt_data","text":"data (encrypt_data, decrypt_data, decrypt_object, decrypt_string) raw vector data encrypted decrypted.  decryption functions must data derived encrypting something get error. key cyphr_key object describing encryption approach use. dest destination filename encrypted decrypted data, NULL return raw vector.  used decrypt_object decrypt_string always return object string. object (encrypt_object) arbitrary R object encrypt.  serialised raw first (see serialize). rds_version RDS serialisation version use (see serialize.  default R version 3.3 version 2 - R 3.4 series version 3 introduced becoming default.  Version 3 format serialisation understood older versions need exchange data older R versions, need use rds_version = 2.  default argument (NULL) ensure serialisation used R use default. string (encrypt_string) scalar character vector encrypt.  converted raw first charToRaw. path (encrypt_file) name file encrypt.  first read R binary (see readBin).","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/encrypt_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Encrypt and decrypt data and other things — encrypt_data","text":"","code":"key <- key_sodium(sodium::keygen()) # Some super secret data we want to encrypt: x <- runif(10) # Convert the data into a raw vector: data <- serialize(x, NULL) data #>   [1] 58 0a 00 00 00 03 00 04 03 02 00 03 05 00 00 00 00 05 55 54 46 2d 38 00 00 #>  [26] 00 0e 00 00 00 0a 3f b4 ac 0a 80 00 00 00 3f ea b2 db 32 a0 00 00 3f e3 39 #>  [51] 6e e4 e0 00 00 3f c4 1f 67 fd 80 00 00 3f 7e 4e e0 60 00 00 00 3f dd d9 64 #>  [76] 1c 80 00 00 3f df db 95 b1 40 00 00 3f d2 8b 8b e9 c0 00 00 3f e7 73 c4 ec #> [101] c0 00 00 3f e8 b8 7f 08 40 00 00 # Encrypt the data; without the key above we will never be able to # decrypt this. data_enc <- encrypt_data(data, key) data_enc #>   [1] 34 dd 24 de 2f 24 b8 9e b6 c1 75 3a 8e 83 ae 3a fa 78 29 3b a7 4c 5b 01 36 #>  [26] 80 2b 35 cb 35 5e 93 87 6b fc a3 5b d9 3b 35 42 b5 c7 76 f1 5d 99 35 32 e5 #>  [51] 30 a7 43 7f ff dd b6 a8 d3 19 d8 7c 2b 44 17 4a 95 81 b3 08 11 47 71 46 e8 #>  [76] 89 ec 62 08 ad 27 59 d0 fa 7f 86 36 35 72 93 40 3e 91 75 84 aa 1a e1 dc 3d #> [101] aa cc 12 f1 6a 81 49 1b f7 a4 6a 21 85 76 88 cc df a6 ac 60 eb 91 a8 cd 63 #> [126] 7f 9a f1 65 07 d5 b9 21 2f 84 1e 9c 11 20 56 98 68 a9 18 dc b6 a9 ca 3c fc #> [151] 8e # Our random numbers: unserialize(decrypt_data(data_enc, key)) #>  [1] 0.080750138 0.834333037 0.600760886 0.157208442 0.007399441 0.466393497 #>  [7] 0.497777389 0.289767245 0.732881987 0.772521511 # Same as the never-encrypted version: x #>  [1] 0.080750138 0.834333037 0.600760886 0.157208442 0.007399441 0.466393497 #>  [7] 0.497777389 0.289767245 0.732881987 0.772521511  # This can be achieved more easily using `encrypt_object`: data_enc <- encrypt_object(x, key) identical(decrypt_object(data_enc, key), x) #> [1] TRUE  # Encrypt strings easily: str_enc <- encrypt_string(\"secret message\", key) str_enc #>  [1] 15 b1 d9 f0 59 11 cf eb 11 b8 2e 58 cc ee f1 5c 22 f0 75 43 f5 f1 9a 25 bd #> [26] 63 d1 9b f7 be 7a 65 05 cc ca bc 14 be 3f 3c d3 1d fe 06 b3 ce 07 68 c9 66 #> [51] da c8 ba 6d decrypt_string(str_enc, key) #> [1] \"secret message\""},{"path":"https://docs.ropensci.org/cyphr/reference/key_openssl.html","id":null,"dir":"Reference","previous_headings":"","what":"Symmetric encryption with openssl — key_openssl","title":"Symmetric encryption with openssl — key_openssl","text":"Wrap openssl symmetric (aes) key.  can used functions encrypt_data() decrypt_data(), along higher level wrappers encrypt() decrypt().  symmetric key, everybody uses key encryption decryption.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/key_openssl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symmetric encryption with openssl — key_openssl","text":"","code":"key_openssl(key, mode = \"cbc\")"},{"path":"https://docs.ropensci.org/cyphr/reference/key_openssl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symmetric encryption with openssl — key_openssl","text":"key openssl aes key (.e., object class aes). mode encryption mode use.  Options cbc, ctr gcm (see openssl package details)","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/key_openssl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Symmetric encryption with openssl — key_openssl","text":"","code":"# Create a new key key <- cyphr::key_openssl(openssl::aes_keygen()) key #> <cyphr_key: openssl>  # With this key encrypt a string secret <- cyphr::encrypt_string(\"my secret string\", key) # And decrypt it again: cyphr::decrypt_string(secret, key) #> [1] \"my secret string\""},{"path":"https://docs.ropensci.org/cyphr/reference/key_sodium.html","id":null,"dir":"Reference","previous_headings":"","what":"Symmetric encryption with sodium — key_sodium","title":"Symmetric encryption with sodium — key_sodium","text":"Wrap sodium symmetric key.  can used functions encrypt_data() decrypt_data(), along higher level wrappers encrypt() decrypt().  symmetric key, everybody uses key encryption decryption.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/key_sodium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symmetric encryption with sodium — key_sodium","text":"","code":"key_sodium(key)"},{"path":"https://docs.ropensci.org/cyphr/reference/key_sodium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symmetric encryption with sodium — key_sodium","text":"key sodium key (.e., generated sodium::keygen()","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/key_sodium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Symmetric encryption with sodium — key_sodium","text":"","code":"# Create a new key key <- cyphr::key_sodium(sodium::keygen()) key #> <cyphr_key: sodium>  # With this key encrypt a string secret <- cyphr::encrypt_string(\"my secret string\", key) # And decrypt it again: cyphr::decrypt_string(secret, key) #> [1] \"my secret string\""},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_openssl.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric encryption with openssl — keypair_openssl","title":"Asymmetric encryption with openssl — keypair_openssl","text":"Wrap pair openssl keys.  pass private key public key person communicating .","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_openssl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric encryption with openssl — keypair_openssl","text":"","code":"keypair_openssl(   pub,   key,   envelope = TRUE,   password = NULL,   authenticated = TRUE )"},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_openssl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric encryption with openssl — keypair_openssl","text":"pub openssl public key.  Usually path key, case may either path public key path directory containing file id_rsa.pub.  NULL, public key used (found via environment variable USER_PUBKEY, ~/.ssh/id_rsa.pub).  However, common use public key - typically want either sender message going decrypt, recipient message want send. key openssl private key.  Usually path key, case may either path private key path directory containing file.  may specify NULL , case environment variable USER_KEY checked defined ~/.ssh/id_rsa used. envelope logical indicating \"envelope\" encryption functions used.  , use openssl::encrypt_envelope() openssl::decrypt_envelope().  FALSE use openssl::rsa_encrypt() openssl::rsa_decrypt(). See openssl docs details.  main effect using envelope = TRUE allow encrypt much larger data envelope = FALSE; openssl asymmetric encryption can encrypt data size key . password password private key.  NULL prompted interactively password, string string used password (careful scripts!) authenticated Logical, indicating result signed public key.  TRUE key verified decryption.  provides tampering detection.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_openssl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric encryption with openssl — keypair_openssl","text":"","code":"# Note this uses password = FALSE for use in examples only, but # this should not be done for any data you actually care about.  # Note that the vignette contains much more information than this # short example and should be referred to before using these # functions.  # Generate two keypairs, one for Alice, and one for Bob path_alice <- tempfile() path_bob <- tempfile() cyphr::ssh_keygen(path_alice, password = FALSE) cyphr::ssh_keygen(path_bob, password = FALSE)  # Alice wants to send Bob a message so she creates a key pair with # her private key and bob's public key (she does not have bob's # private key). pair_alice <- cyphr::keypair_openssl(pub = path_bob, key = path_alice)  # She can then encrypt a secret message: secret <- cyphr::encrypt_string(\"hi bob\", pair_alice) secret #>   [1] 58 0a 00 00 00 03 00 04 03 02 00 03 05 00 00 00 00 05 55 54 46 2d 38 00 00 #>  [26] 02 13 00 00 00 04 00 00 00 18 00 00 00 10 6b e0 d8 3e 1e d8 e1 a5 d5 b3 e6 #>  [51] 50 8d 2f b8 cc 00 00 00 18 00 00 01 00 a3 80 48 b3 ec 5c ef bd 20 8f d5 fc #>  [76] b8 96 e2 07 bd e0 ff 1a 7e 18 3e 9b 50 60 62 1e 27 3f 8c 67 4c cc 1f 23 ef #> [101] ee f8 d3 40 aa 03 0f ba 94 19 6e cb fb 91 29 e6 1d 2f f1 28 15 f4 1b 87 25 #> [126] 43 28 d9 aa 26 11 59 3a 00 d6 73 b1 6a dd 4c 16 92 bc d3 ba fd 24 60 fb c4 #> [151] 13 f2 32 b2 79 48 09 85 87 2b 06 b8 f9 ce 76 e6 ed d9 a5 35 39 78 0c df 32 #> [176] b9 f0 41 cd f1 a2 82 58 62 dc c9 22 da b1 49 6d 35 7e 80 8d 24 be 43 d6 6a #> [201] 8d f0 d3 2f fe 60 f0 ec e3 3d 47 1a 81 c3 06 03 59 a4 4b e0 8f 4e 51 d1 2e #> [226] cb 87 76 a4 26 28 71 a7 17 0a ca 25 ea 19 98 2b 55 61 fc c7 45 7a 29 a0 8c #> [251] 3e 49 28 8f 6e a8 6e c7 18 0a 35 ac b6 40 f0 2a 6b a6 0e b4 47 01 f3 eb 29 #> [276] 21 ba b2 ec 08 48 60 e0 38 43 5b e2 24 7a 39 6d 12 9f f3 10 e1 3e 42 77 60 #> [301] b1 ec 6a 07 40 9b 25 e4 d1 83 91 26 b4 c5 75 eb 1e d3 d1 00 00 00 18 00 00 #> [326] 00 10 45 a9 d5 d7 08 df 64 cd 32 64 36 61 59 72 c9 22 00 00 00 18 00 00 01 #> [351] 00 4f df 4a d1 9d e7 ef f9 4f b6 6b 8c 21 51 74 32 6a 11 54 fe 7c 02 ec 72 #> [376] 2a 1a b6 1e 12 b4 1d a7 22 27 63 10 05 ab 07 01 03 2b 76 ab 3f e1 d2 92 3b #> [401] fe 48 4a c2 42 9d fd db 85 67 4c f2 3b 89 15 ec 3e bc d3 bc 5f 98 a9 8c be #> [426] d9 bd dd 1e 9f 2c dd 2e 0b a3 39 60 7f 7c 1b c2 9b 73 bd 02 c2 8a 55 b1 c4 #> [451] ac b9 13 1c 2d ef 83 e5 d9 d3 7e 01 8b 92 1b 23 e5 a4 06 9d ad 1c 64 98 75 #> [476] e7 f6 65 c0 ab 70 27 f7 3a 4a 52 a1 db ae 8b 9b e1 c5 76 c4 98 6e 5d b2 41 #> [501] 57 1f 7a 18 49 a5 04 1d 6c ab e8 b2 16 90 7f 0c ab 25 63 ca 56 78 90 b0 d7 #> [526] fe 80 ef 16 c5 01 3c 35 43 13 b7 bf 22 78 a1 81 3f 34 1e 7d 23 4d 0b 46 14 #> [551] 6a c5 9f c3 47 50 21 c8 7f ea 0a d9 8b a3 61 57 7c 82 58 aa 0e c7 22 51 b2 #> [576] 21 b7 a4 a6 07 ba f0 0e 2e 77 1f e9 c9 fa 92 d0 7e 37 f1 2e 40 55 fa c9 e2 #> [601] 40 21 0a b6 45 c7 9c 00 00 04 02 00 00 00 01 00 04 00 09 00 00 00 05 6e 61 #> [626] 6d 65 73 00 00 00 10 00 00 00 04 00 04 00 09 00 00 00 02 69 76 00 04 00 09 #> [651] 00 00 00 07 73 65 73 73 69 6f 6e 00 04 00 09 00 00 00 04 64 61 74 61 00 04 #> [676] 00 09 00 00 00 09 73 69 67 6e 61 74 75 72 65 00 00 00 fe  # Bob wants to read the message so he creates a key pair using # Alice's public key and his private key: pair_bob <- cyphr::keypair_openssl(pub = path_alice, key = path_bob)  cyphr::decrypt_string(secret, pair_bob) #> [1] \"hi bob\"  # Clean up unlink(path_alice, recursive = TRUE) unlink(path_bob, recursive = TRUE)"},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_sodium.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric encryption with sodium — keypair_sodium","title":"Asymmetric encryption with sodium — keypair_sodium","text":"Wrap pair sodium keys asymmetric encryption.  pass private key public key person communicating .","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_sodium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric encryption with sodium — keypair_sodium","text":"","code":"keypair_sodium(pub, key, authenticated = TRUE)"},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_sodium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric encryption with sodium — keypair_sodium","text":"pub sodium public key.  either raw vector length 32 path file containing contents key (written writeBin()). key sodium private key.  either raw vector length 32 path file containing contents key (written writeBin()). authenticated Logical, indicating authenticated encryption (via sodium::auth_encrypt() / sodium::auth_decrypt()) used.  FALSE sodium::simple_encrypt() / sodium::simple_decrypt() used.  difference authenticated = TRUE message signed private key tampering message detected.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_sodium.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Asymmetric encryption with sodium — keypair_sodium","text":"NOTE: order (pub, key) important; wrong order used decrypt things.  Unfortunately sodium keys just byte sequences nothing distinguish public private keys pretty easy mistake make.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/cyphr/reference/keypair_sodium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric encryption with sodium — keypair_sodium","text":"","code":"# Generate two keypairs, one for Alice, and one for Bob key_alice <- sodium::keygen() pub_alice <- sodium::pubkey(key_alice) key_bob <- sodium::keygen() pub_bob <- sodium::pubkey(key_bob)  # Alice wants to send Bob a message so she creates a key pair with # her private key and bob's public key (she does not have bob's # private key). pair_alice <- cyphr::keypair_sodium(pub = pub_bob, key = key_alice)  # She can then encrypt a secret message: secret <- cyphr::encrypt_string(\"hi bob\", pair_alice) secret #>  [1] 29 09 9f 09 96 03 ad 7f dc f4 ef e4 54 87 e1 08 91 c7 db 29 85 cd 3e 59 71 #> [26] 47 79 00 79 98 a4 f2 5a d0 87 27 96 d6 02 c5 ad ec e0 f6 e0 18  # Bob wants to read the message so he creates a key pair using # Alice's public key and his private key: pair_bob <- cyphr::keypair_sodium(pub = pub_alice, key = key_bob)  cyphr::decrypt_string(secret, pair_bob) #> [1] \"hi bob\""},{"path":"https://docs.ropensci.org/cyphr/reference/rewrite_register.html","id":null,"dir":"Reference","previous_headings":"","what":"Register functions to work with encrypt/decrypt — rewrite_register","title":"Register functions to work with encrypt/decrypt — rewrite_register","text":"Add information argument rewriting can used encrypt decrypt.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/rewrite_register.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register functions to work with encrypt/decrypt — rewrite_register","text":"","code":"rewrite_register(package, name, arg, fn = NULL)"},{"path":"https://docs.ropensci.org/cyphr/reference/rewrite_register.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register functions to work with encrypt/decrypt — rewrite_register","text":"package name package function support (scalar character).  function package (e.g., function working outside package, use \"\" name). name name function support. arg name argument target function refers file encrypted decrypted.  value pass file_arg encrypt. fn Optional (rare) argument used work around functions pass arguments second function dots.  read.csv works.  needed function length-2 character vector form \"package\", \"name\" actual function used.  rare!","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/rewrite_register.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register functions to work with encrypt/decrypt — rewrite_register","text":"package uses cyphr, might useful add .onLoad() hook.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/rewrite_register.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register functions to work with encrypt/decrypt — rewrite_register","text":"","code":"# The saveRDS function is already supported.  But if we wanted to # support it we could look at the arguments for the function: args(saveRDS) #> function (object, file = \"\", ascii = FALSE, version = NULL, compress = TRUE,  #>     refhook = NULL)  #> NULL # The 'file' argument is the one that refers to the filename, so # we'd write: cyphr::rewrite_register(\"base\", \"saveRDS\", \"file\") # It's non-API but you can see what is supported in the package by # looking at ls(cyphr:::db) #>  [1] \"base::load\"          \"base::readLines\"     \"base::readRDS\"       #>  [4] \"base::save\"          \"base::saveRDS\"       \"base::writeLines\"    #>  [7] \"readxl::read_excel\"  \"readxl::read_xls\"    \"readxl::read_xlsx\"   #> [10] \"utils::read.csv\"     \"utils::read.csv2\"    \"utils::read.delim\"   #> [13] \"utils::read.delim2\"  \"utils::read.table\"   \"utils::write.csv\"    #> [16] \"utils::write.csv2\"   \"utils::write.table\"  \"writexl::write_xlsx\""},{"path":"https://docs.ropensci.org/cyphr/reference/session_key_refresh.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh the session key — session_key_refresh","title":"Refresh the session key — session_key_refresh","text":"Refresh session key, invalidating keys created key_openssl(), keypair_openssl(), key_sodium() keypair_sodium().","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/session_key_refresh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh the session key — session_key_refresh","text":"","code":"session_key_refresh()"},{"path":"https://docs.ropensci.org/cyphr/reference/session_key_refresh.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refresh the session key — session_key_refresh","text":"Running function invalidate keys loaded functions.  needed often.","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/session_key_refresh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refresh the session key — session_key_refresh","text":"","code":"# Be careful - if you run this then all keys loaded from file will # no longer work until reloaded if (FALSE) {   cyphr::session_key_refresh() }"},{"path":"https://docs.ropensci.org/cyphr/reference/ssh_keygen.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ssh keypairs — ssh_keygen","title":"Create ssh keypairs — ssh_keygen","text":"Create openssl key pairs manner ssh-keygen(1). general used (generate keys ssh-keygen command line.  However useful testing demonstration included make easier.  keypair generated can used keypair_openssl().","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/ssh_keygen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ssh keypairs — ssh_keygen","text":"","code":"ssh_keygen(path = tempfile(), password = TRUE, use_shell = FALSE)"},{"path":"https://docs.ropensci.org/cyphr/reference/ssh_keygen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ssh keypairs — ssh_keygen","text":"path directory create keypair.  path exist created. password password key.  default prompt interactively (without echoing password).  valid options FALSE (password) string. use_shell Try use ssh-keygen (shell utility) rather functions openssl package.  necessary least old versions OS/X (Yosemite older least) keys generated openssl package read system ssh commands (e.g., ssh-add).","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/ssh_keygen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ssh keypairs — ssh_keygen","text":"path, invisibly.  useful case path tempfile().","code":""},{"path":"https://docs.ropensci.org/cyphr/reference/ssh_keygen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ssh keypairs — ssh_keygen","text":"","code":"# Generate a new key in a temporary directory: path <- cyphr::ssh_keygen(password = FALSE) dir(path) # will contain id_rsa and id_rsa.pub #> [1] \"id_rsa\"     \"id_rsa.pub\"  # This key can now be used via keypair_openssl: key <- cyphr::keypair_openssl(path, path) secret <- cyphr::encrypt_string(\"hello\", key) cyphr::decrypt_string(secret, key) #> [1] \"hello\"  # Cleanup unlink(path, recursive = TRUE)"},{"path":"https://docs.ropensci.org/cyphr/news/index.html","id":"cyphr-106","dir":"Changelog","previous_headings":"","what":"cyphr 1.0.6","title":"cyphr 1.0.6","text":"Added wrappers readxl::read_excel writexl::write_xlsx (reside-109) Support custom messages requesting authorising access data (reside-108)","code":""},{"path":"https://docs.ropensci.org/cyphr/news/index.html","id":"cyphr-101","dir":"Changelog","previous_headings":"","what":"cyphr 1.0.1","title":"cyphr 1.0.1","text":"CRAN release: 2019-03-23 First CRAN release","code":""},{"path":"https://docs.ropensci.org/cyphr/news/index.html","id":"cyphr-020","dir":"Changelog","previous_headings":"","what":"cyphr 0.2.0","title":"cyphr 0.2.0","text":"Authenticated encryption (signed messages) now supported openssl, enabled default. Along pack format openssl changed break existing uses package (don’t believe )","code":""},{"path":"https://docs.ropensci.org/cyphr/news/index.html","id":"cyphr-010","dir":"Changelog","previous_headings":"","what":"cyphr 0.1.0","title":"cyphr 0.1.0","text":"Initial prototype, sent rOpenSci onboarding review","code":""}]
